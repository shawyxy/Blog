---
title: "区间并查集"
open: true
math: true
---
[1851\. 包含每个查询的最小区间](https://leetcode.cn/problems/minimum-interval-to-include-each-query/description/)
------------------------------------------------------------------------------------------------------

给你一个二维整数数组 `intervals` ，其中 `intervals[i] = [lefti, righti]` 表示第 `i` 个区间开始于 `lefti` 、结束于 `righti`（包含两侧取值，**闭区间**）。区间的 **长度** 定义为区间中包含的整数数目，更正式地表达是 `righti - lefti + 1` 。

再给你一个整数数组 `queries` 。第 `j` 个查询的答案是满足 `lefti <= queries[j] <= righti` 的 **长度最小区间 `i` 的长度** 。如果不存在这样的区间，那么答案是 `-1` 。

以数组形式返回对应查询的所有答案。

**示例 1：**

**输入：**intervals = \[\[1,4\],\[2,4\],\[3,6\],\[4,4\]\], queries = \[2,3,4,5\]
**输出：**\[3,3,1,4\]
**解释：**查询处理如下：
- Query = 2 ：区间 \[2,4\] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。
- Query = 3 ：区间 \[2,4\] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。
- Query = 4 ：区间 \[4,4\] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。
- Query = 5 ：区间 \[3,6\] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。

**示例 2：**

**输入：**intervals = \[\[2,3\],\[2,5\],\[1,8\],\[20,25\]\], queries = \[2,19,5,22\]
**输出：**\[2,-1,4,6\]
**解释：**查询处理如下：
- Query = 2 ：区间 \[2,3\] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。
- Query = 19：不存在包含 19 的区间，答案为 -1 。
- Query = 5 ：区间 \[2,5\] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。
- Query = 22：区间 \[20,25\] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。

**提示：**

*   `1 <= intervals.length <= 105`
*   `1 <= queries.length <= 105`
*   `intervals[i].length == 2`
*   `1 <= lefti <= righti <= 107`
*   `1 <= queries[j] <= 107`

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[3244\. 新增道路查询后的最短距离 II](https://leetcode.cn/problems/shortest-distance-after-road-addition-queries-ii/description/)
--------------------------------------------------------------------------------------------------------------------

给你一个整数 `n` 和一个二维整数数组 `queries`。

有 `n` 个城市，编号从 `0` 到 `n - 1`。初始时，每个城市 `i` 都有一条**单向**道路通往城市 `i + 1`（ `0 <= i < n - 1`）。

`queries[i] = [ui, vi]` 表示新建一条从城市 `ui` 到城市 `vi` 的**单向**道路。每次查询后，你需要找到从城市 `0` 到城市 `n - 1` 的**最短路径**的**长度**。

所有查询中不会存在两个查询都满足 `queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1]`。

返回一个数组 `answer`，对于范围 `[0, queries.length - 1]` 中的每个 `i`，`answer[i]` 是处理完**前** `i + 1` 个查询后，从城市 `0` 到城市 `n - 1` 的最短路径的_长度_。

**示例 1：**

**输入：** n = 5, queries = \[\[2, 4\], \[0, 2\], \[0, 4\]\]

**输出：** \[3, 2, 1\]

**解释：**

![](https://assets.leetcode.com/uploads/2024/06/28/image8.jpg)

新增一条从 2 到 4 的道路后，从 0 到 4 的最短路径长度为 3。

![](https://assets.leetcode.com/uploads/2024/06/28/image9.jpg)

新增一条从 0 到 2 的道路后，从 0 到 4 的最短路径长度为 2。

![](https://assets.leetcode.com/uploads/2024/06/28/image10.jpg)

新增一条从 0 到 4 的道路后，从 0 到 4 的最短路径长度为 1。

**示例 2：**

**输入：** n = 4, queries = \[\[0, 3\], \[0, 2\]\]

**输出：** \[1, 1\]

**解释：**

![](https://assets.leetcode.com/uploads/2024/06/28/image11.jpg)

新增一条从 0 到 3 的道路后，从 0 到 3 的最短路径长度为 1。

![](https://assets.leetcode.com/uploads/2024/06/28/image12.jpg)

新增一条从 0 到 2 的道路后，从 0 到 3 的最短路径长度仍为 1。

**提示:**

*   `3 <= n <= 105`
*   `1 <= queries.length <= 105`
*   `queries[i].length == 2`
*   `0 <= queries[i][0] < queries[i][1] < n`
*   `1 < queries[i][1] - queries[i][0]`
*   查询中不存在重复的道路。
*   不存在两个查询都满足 `i != j` 且 `queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1]`。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。



### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。



### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。



### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。



### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。



### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。



### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。



### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。



### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。



### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。



### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。