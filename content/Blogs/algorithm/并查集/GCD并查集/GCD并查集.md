---
title: "GCD并查集"
open: true
math: true
---
[2709\. 最大公约数遍历](https://leetcode.cn/problems/greatest-common-divisor-traversal/description/)
---------------------------------------------------------------------------------------------

给你一个下标从 **0** 开始的整数数组 `nums` ，你可以在一些下标之间遍历。对于两个下标 `i` 和 `j`（`i != j`），当且仅当 `gcd(nums[i], nums[j]) > 1` 时，我们可以在两个下标之间通行，其中 `gcd` 是两个数的 **最大公约数** 。

你需要判断 `nums` 数组中 **任意** 两个满足 `i < j` 的下标 `i` 和 `j` ，是否存在若干次通行可以从 `i` 遍历到 `j` 。

如果任意满足条件的下标对都可以遍历，那么返回 `true` ，否则返回 `false` 。

**示例 1：**

**输入：**nums = \[2,3,6\]
**输出：**true
**解释：**这个例子中，总共有 3 个下标对：(0, 1) ，(0, 2) 和 (1, 2) 。
从下标 0 到下标 1 ，我们可以遍历 0 -> 2 -> 1 ，我们可以从下标 0 到 2 是因为 gcd(nums\[0\], nums\[2\]) = gcd(2, 6) = 2 > 1 ，从下标 2 到 1 是因为 gcd(nums\[2\], nums\[1\]) = gcd(6, 3) = 3 > 1 。
从下标 0 到下标 2 ，我们可以直接遍历，因为 gcd(nums\[0\], nums\[2\]) = gcd(2, 6) = 2 > 1 。同理，我们也可以从下标 1 到 2 因为 gcd(nums\[1\], nums\[2\]) = gcd(3, 6) = 3 > 1 。

**示例 2：**

**输入：**nums = \[3,9,5\]
**输出：**false
**解释：**我们没法从下标 0 到 2 ，所以返回 false 。

**示例 3：**

**输入：**nums = \[4,3,12,8\]
**输出：**true
**解释：**总共有 6 个下标对：(0, 1) ，(0, 2) ，(0, 3) ，(1, 2) ，(1, 3) 和 (2, 3) 。所有下标对之间都存在可行的遍历，所以返回 true 。

**提示：**

*   `1 <= nums.length <= 105`
*   `1 <= nums[i] <= 105`

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[1627\. 带阈值的图连通性](https://leetcode.cn/problems/graph-connectivity-with-threshold/description/)
----------------------------------------------------------------------------------------------

有 `n` 座城市，编号从 `1` 到 `n` 。编号为 `x` 和 `y` 的两座城市直接连通的前提是： `x` 和 `y` 的公因数中，至少有一个 **严格大于** 某个阈值 `threshold` 。更正式地说，如果存在整数 `z` ，且满足以下所有条件，则编号 `x` 和 `y` 的城市之间有一条道路：

*   `x % z == 0`
*   `y % z == 0`
*   `z > threshold`

给你两个整数 `n` 和 `threshold` ，以及一个待查询数组，请你判断每个查询 `queries[i] = [ai, bi]` 指向的城市 `ai` 和 `bi` 是否连通（即，它们之间是否存在一条路径）。

返回数组 `answer` ，其中`answer.length == queries.length` 。如果第 `i` 个查询中指向的城市 `ai` 和 `bi` 连通，则 `answer[i]` 为 `true` ；如果不连通，则 `answer[i]` 为 `false` 。

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/18/ex1.jpg)

**输入：**n = 6, threshold = 2, queries = \[\[1,4\],\[2,5\],\[3,6\]\]
**输出：**\[false,false,true\]
**解释：**每个数的因数如下：
1:   1
2:   1, 2
3:   1, **3**
4:   1, 2, **4**
5:   1, **5**
6:   1, 2, **3**, **6**
所有大于阈值的的因数已经加粗标识，只有城市 3 和 6 共享公约数 3 ，因此结果是： 
\[1,4\]   1 与 4 不连通
\[2,5\]   2 与 5 不连通
\[3,6\]   3 与 6 连通，存在路径 3--6

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/18/tmp.jpg)

**输入：**n = 6, threshold = 0, queries = \[\[4,5\],\[3,4\],\[3,2\],\[2,6\],\[1,3\]\]
**输出：**\[true,true,true,true,true\]
**解释：**每个数的因数与上一个例子相同。但是，由于阈值为 0 ，所有的因数都大于阈值。因为所有的数字共享公因数 1 ，所以所有的城市都互相连通。

**示例 3：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/16/ex3.jpg)

**输入：**n = 5, threshold = 1, queries = \[\[4,5\],\[4,5\],\[3,2\],\[2,3\],\[3,4\]\]
**输出：**\[false,false,false,false,false\]
**解释：**只有城市 2 和 4 共享的公约数 2 严格大于阈值 1 ，所以只有这两座城市是连通的。
注意，同一对节点 \[x, y\] 可以有多个查询，并且查询 \[x，y\] 等同于查询 \[y，x\] 。

**提示：**

*   `2 <= n <= 104`
*   `0 <= threshold <= n`
*   `1 <= queries.length <= 105`
*   `queries[i].length == 2`
*   `1 <= ai, bi <= cities`
*   `ai != bi`

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[952\. 按公因数计算最大组件大小](https://leetcode.cn/problems/largest-component-size-by-common-factor/description/)
-------------------------------------------------------------------------------------------------------

给定一个由不同正整数的组成的非空数组 `nums` ，考虑下面的图：

*   有 `nums.length` 个节点，按从 `nums[0]` 到 `nums[nums.length - 1]` 标记；
*   只有当 `nums[i]` 和 `nums[j]` 共用一个大于 1 的公因数时，`nums[i]` 和 `nums[j]`之间才有一条边。

返回 _图中最大连通组件的大小_ 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2018/12/01/ex1.png)

**输入：**nums = \[4,6,15,35\]
**输出：**4

**示例 2：**

![](https://assets.leetcode.com/uploads/2018/12/01/ex2.png)

**输入：**nums = \[20,50,9,63\]
**输出：**2

**示例 3：**

![](https://assets.leetcode.com/uploads/2018/12/01/ex3.png)

**输入：**nums = \[2,3,6,7,4,12,21,39\]
**输出：**8

**提示：**

*   `1 <= nums.length <= 2 * 104`
*   `1 <= nums[i] <= 105`
*   `nums` 中所有值都 **不同**

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[1998\. 数组的最大公因数排序](https://leetcode.cn/problems/gcd-sort-of-an-array/description/)
-----------------------------------------------------------------------------------

给你一个整数数组 `nums` ，你可以在 `nums` 上执行下述操作 **任意次** ：

*   如果 `gcd(nums[i], nums[j]) > 1` ，交换 `nums[i]` 和 `nums[j]` 的位置。其中 `gcd(nums[i], nums[j])` 是 `nums[i]` 和 `nums[j]` 的最大公因数。

如果能使用上述交换方式将 `nums` 按 **非递减顺序** 排列，返回 `true` ；否则，返回 `false` 。

**示例 1：**

**输入：**nums = \[7,21,3\]
**输出：**true
**解释：**可以执行下述操作完成对 \[7,21,3\] 的排序：
- 交换 7 和 21 因为 gcd(7,21) = 7 。nums = \[**21**,**7**,3\]
- 交换 21 和 3 因为 gcd(21,3) = 3 。nums = \[**3**,7,**21**\]

**示例 2：**

**输入：**nums = \[5,2,6,2\]
**输出：**false
**解释：**无法完成排序，因为 5 不能与其他元素交换。

**示例 3：**

**输入：**nums = \[10,5,9,3,15\]
**输出：**true
**解释：**
可以执行下述操作完成对 \[10,5,9,3,15\] 的排序：
- 交换 10 和 15 因为 gcd(10,15) = 5 。nums = \[**15**,5,9,3,**10**\]
- 交换 15 和 3 因为 gcd(15,3) = 3 。nums = \[**3**,5,9,**15**,10\]
- 交换 10 和 15 因为 gcd(10,15) = 5 。nums = \[3,5,9,**10**,**15**\]

**提示：**

*   `1 <= nums.length <= 3 * 104`
*   `2 <= nums[i] <= 105`

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。