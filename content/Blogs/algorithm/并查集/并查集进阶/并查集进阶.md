---
title: "并查集进阶"
open: true
math: true
---
[56\. 合并区间](https://leetcode.cn/problems/merge-intervals/description/)
----------------------------------------------------------------------

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 _一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间_ 。

**示例 1：**

**输入：**intervals = \[\[1,3\],\[2,6\],\[8,10\],\[15,18\]\]
**输出：**\[\[1,6\],\[8,10\],\[15,18\]\]
**解释：**区间 \[1,3\] 和 \[2,6\] 重叠, 将它们合并为 \[1,6\].

**示例 2：**

**输入：**intervals = \[\[1,4\],\[4,5\]\]
**输出：**\[\[1,5\]\]
**解释：**区间 \[1,4\] 和 \[4,5\] 可被视为重叠区间。

**提示：**

*   `1 <= intervals.length <= 10^4`
*   `intervals[i].length == 2`
*   `0 <= starti <= endi <= 10^4`

### 算法

#### 思路

这道题虽然有更高效更易懂的解法，但是用并查集做这道题还是具有一定启发意义的。

并查集的思路：

1. 区间连接：把每个区间的起点和终点看作一个范围，使用并查集将每个区间的范围内的所有点进行合并。如果两个区间有重叠或者相邻，它们的终点和起点也需要被连接在一起。
2. 区间合并：通过并查集的“父节点”可以找出所有相连的区间，最后通过这些连接点，合并成一个较大的区间。
3. 区间边界处理：我们需要追踪每个连通区域的最小起点和最大终点。

实现步骤：

1. 初始化并查集，将每个区间的所有点都看作单独的节点。
2. 遍历所有区间，合并相邻或重叠的区间。
3. 最终，根据并查集找到连通的区间并输出合并后的区间。

#### 代码

```cpp
class Solution {
public:
    static const int N = 10010;
    int fa[N];
    int minPoint[N];  // 每个集合中最小的起点
    int maxPoint[N];  // 每个集合中最大的终点
    
    int find(int x) {
        if (fa[x] == x) return x;
        return fa[x] = find(fa[x]);
    }

    void unite(int x, int y) {
        int fx = find(x), fy = find(y);
        if (fx != fy) {
            // 合并两个集合时，同时更新区间的最小起点和最大终点
            fa[fy] = fx;
            minPoint[fx] = min(minPoint[fx], minPoint[fy]);
            maxPoint[fx] = max(maxPoint[fx], maxPoint[fy]);
        }
    }

    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        
        for (int i = 0; i < N; i++) {
            fa[i] = i;
            minPoint[i] = i;
            maxPoint[i] = i;
        }
        // 遍历区间，合并相邻或重叠的区间
        for (auto& interval : intervals) {
            int start = interval[0];
            int end = interval[1];
            // 遍历当前区间内的所有点，将它们合并
            for (int i = start; i < end; i++) {
                unite(i, i + 1);
            }
        }
        // 通过并查集找到合并后的区间
        unordered_set<int> seen;  // 用于追踪已经处理的区间
        for (auto& interval : intervals) {
            int start = find(interval[0]);
            if (seen.count(start)) continue;  // 跳过已经合并的区间
            seen.insert(start);
            res.push_back({minPoint[start], maxPoint[start]});
        }
        return res;
    }
};

```

在并查集合并集合时，如果有必要，可以在合并后进行相应的操作。

#### 复杂度分析

- 时间复杂度：$O(n + m)$，其中 $n$ 是点的数量，$m$ 是区间数量。
- 空间复杂度：$O(n + m)$。

[1202\. 交换字符串中的元素](https://leetcode.cn/problems/smallest-string-with-swaps/description/)
----------------------------------------------------------------------------------------

给你一个字符串 `s`，以及该字符串中的一些「索引对」数组 `pairs`，其中 `pairs[i] = [a, b]` 表示字符串中的两个索引（编号从 0 开始）。

你可以 **任意多次交换** 在 `pairs` 中任意一对索引处的字符。

返回在经过若干次交换后，`s` 可以变成的按字典序最小的字符串。

**示例 1:**

**输入：**s = "dcab", pairs = \[\[0,3\],\[1,2\]\]
**输出：**"bacd"
**解释：** 
交换 s\[0\] 和 s\[3\], s = "bcad"
交换 s\[1\] 和 s\[2\], s = "bacd"

**示例 2：**

**输入：**s = "dcab", pairs = \[\[0,3\],\[1,2\],\[0,2\]\]
**输出：**"abcd"
**解释：**
交换 s\[0\] 和 s\[3\], s = "bcad"
交换 s\[0\] 和 s\[2\], s = "acbd"
交换 s\[1\] 和 s\[2\], s = "abcd"

**示例 3：**

**输入：**s = "cba", pairs = \[\[0,1\],\[1,2\]\]
**输出：**"abc"
**解释：**
交换 s\[0\] 和 s\[1\], s = "bca"
交换 s\[1\] 和 s\[2\], s = "bac"
交换 s\[0\] 和 s\[1\], s = "abc"

**提示：**

*   `1 <= s.length <= 10^5`
*   `0 <= pairs.length <= 10^5`
*   `0 <= pairs[i][0], pairs[i][1] < s.length`
*   `s` 中只含有小写英文字母

### 算法

#### 思路

交换的操作具有传递性，比如示例3，0和1可以交换，0和也可以交换，那么0,1,2都可以随便交换，那么直接对0~2之间的字符排序就好。

考虑用并查集将所有具有传递性的区间合并，以连通块的根节点为key，在哈希表中记录这个连通块对应的字串，然后对其排序。

最后遍历原字符串，对于每个字符，我们要做的事情是替换：找到它所属的连通块，也就是在哈希表中排序好的子串，把最后一个最小的字符替换当前字符，然后在连通块中把它删除。

#### 代码

```cpp
class Solution {
public:
    static const int N = 1e5+10;
    int fa[N];
    void init(int n) {
        iota(fa, fa + n, 0);
    }
    int find(int x) {
        if (x == fa[x]) return x;
        return fa[x] = find(fa[x]);
    }
    void unite(int x, int y) {
        x = find(x), y = find(y);
        if (x != y) {
            fa[x] = y;

        }
    }
    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {
        int n = s.size();
        init(n);
        for (auto &e : pairs) unite(e[0], e[1]);
        unordered_map<int, vector<char>> map;
        for (int i = 0; i < n; i++) map[find(i)].push_back(s[i]);
        for (auto &[k, v] : map) {
            sort(v.begin(), v.end(), greater<char>());
        }
        for (int i = 0; i < n; i++) {
            int x = find(i);
            s[i] = map[x].back();
            map[x].pop_back();
        }
        return s;
    }
};
```



#### 复杂度分析

- 时间复杂度：$O(n \log n)$。并查集合并和查找均摊时间复杂度为$O(1)$，最多要对$s$的所有字符排序。
- 空间复杂度：$O(n)$。

[1061\. 按字典序排列最小的等效字符串](https://leetcode.cn/problems/lexicographically-smallest-equivalent-string/description/)
---------------------------------------------------------------------------------------------------------------

给出长度相同的两个字符串`s1` 和 `s2` ，还有一个字符串 `baseStr` 。

其中  `s1[i]` 和 `s2[i]`  是一组等价字符。

*   举个例子，如果 `s1 = "abc"` 且 `s2 = "cde"`，那么就有 `'a' == 'c', 'b' == 'd', 'c' == 'e'`。

等价字符遵循任何等价关系的一般规则：

*    **自反性** ：`'a' == 'a'`
*    **对称性** ：`'a' == 'b'` 则必定有 `'b' == 'a'`
*    **传递性** ：`'a' == 'b'` 且 `'b' == 'c'` 就表明 `'a' == 'c'`

例如， `s1 = "abc"` 和 `s2 = "cde"` 的等价信息和之前的例子一样，那么 `baseStr = "eed"` , `"acd"` 或 `"aab"`，这三个字符串都是等价的，而 `"aab"` 是 `baseStr` 的按字典序最小的等价字符串

利用 `s1` 和 `s2` 的等价信息，找出并返回 `baseStr` 的按字典序排列最小的等价字符串。

**示例 1：**

**输入：**s1 = "parker", s2 = "morris", baseStr = "parser"
**输出：**"makkek"
**解释：**根据 `A` 和 `B 中的等价信息，`我们可以将这些字符分为 `[m,p]`, `[a,o]`, `[k,r,s]`, `[e,i] 共 4 组`。每组中的字符都是等价的，并按字典序排列。所以答案是 `"makkek"`。

**示例 2：**

**输入：**s1 = "hello", s2 = "world", baseStr = "hold"
**输出：**"hdld"
**解释：**根据 `A` 和 `B 中的等价信息，`我们可以将这些字符分为 `[h,w]`, `[d,e,o]`, `[l,r] 共 3 组`。所以只有 S 中的第二个字符 `'o'` 变成 `'d'，最后答案为` `"hdld"`。

**示例 3：**

**输入：**s1 = "leetcode", s2 = "programs", baseStr = "sourcecode"
**输出：**"aauaaaaada"
**解释：**我们可以把 A 和 B 中的等价字符分为 `[a,o,e,r,s,c]`, `[l,p]`, `[g,t]` 和 `[d,m] 共 4 组`，因此 `S` 中除了 `'u'` 和 `'d'` 之外的所有字母都转化成了 `'a'`，最后答案为 `"aauaaaaada"`。

**提示：**

*   `1 <= s1.length, s2.length, baseStr <= 1000`
*   `s1.length == s2.length`
*   字符串`s1`, `s2`, and `baseStr` 仅由从 `'a'` 到 `'z'` 的小写英文字母组成。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[1722\. 执行交换操作后的最小汉明距离](https://leetcode.cn/problems/minimize-hamming-distance-after-swap-operations/description/)
------------------------------------------------------------------------------------------------------------------

给你两个整数数组 `source` 和 `target` ，长度都是 `n` 。还有一个数组 `allowedSwaps` ，其中每个 `allowedSwaps[i] = [ai, bi]` 表示你可以交换数组 `source` 中下标为 `ai` 和 `bi`（**下标从 0 开始**）的两个元素。注意，你可以按 **任意** 顺序 **多次** 交换一对特定下标指向的元素。

相同长度的两个数组 `source` 和 `target` 间的 **汉明距离** 是元素不同的下标数量。形式上，其值等于满足 `source[i] != target[i]` （**下标从 0 开始**）的下标 `i`（`0 <= i <= n-1`）的数量。

在对数组 `source` 执行 **任意** 数量的交换操作后，返回 `source` 和 `target` 间的 **最小汉明距离** 。

**示例 1：**

**输入：**source = \[1,2,3,4\], target = \[2,1,4,5\], allowedSwaps = \[\[0,1\],\[2,3\]\]
**输出：**1
**解释：**source 可以按下述方式转换：
- 交换下标 0 和 1 指向的元素：source = \[**2**,**1**,3,4\]
- 交换下标 2 和 3 指向的元素：source = \[2,1,**4**,**3**\]
source 和 target 间的汉明距离是 1 ，二者有 1 处元素不同，在下标 3 。

**示例 2：**

**输入：**source = \[1,2,3,4\], target = \[1,3,2,4\], allowedSwaps = \[\]
**输出：**2
**解释：**不能对 source 执行交换操作。
source 和 target 间的汉明距离是 2 ，二者有 2 处元素不同，在下标 1 和下标 2 。

**示例 3：**

**输入：**source = \[5,1,2,4,3\], target = \[1,5,4,2,3\], allowedSwaps = \[\[0,4\],\[4,2\],\[1,3\],\[1,4\]\]
**输出：**0

**提示：**

*   `n == source.length == target.length`
*   `1 <= n <= 105`
*   `1 <= source[i], target[i] <= 105`
*   `0 <= allowedSwaps.length <= 105`
*   `allowedSwaps[i].length == 2`
*   `0 <= ai, bi <= n - 1`
*   `ai != bi`

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[765\. 情侣牵手](https://leetcode.cn/problems/couples-holding-hands/description/)
-----------------------------------------------------------------------------

`n` 对情侣坐在连续排列的 `2n` 个座位上，想要牵到对方的手。

人和座位由一个整数数组 `row` 表示，其中 `row[i]` 是坐在第 `i` 个座位上的人的 **ID**。情侣们按顺序编号，第一对是 `(0, 1)`，第二对是 `(2, 3)`，以此类推，最后一对是 `(2n-2, 2n-1)`。

返回 _最少交换座位的次数，以便每对情侣可以并肩坐在一起_。 _每次_交换可选择任意两人，让他们站起来交换座位。

**示例 1:**

**输入:** row = \[0,2,1,3\]
**输出:** 1
**解释:** 只需要交换row\[1\]和row\[2\]的位置即可。

**示例 2:**

**输入:** row = \[3,2,0,1\]
**输出:** 0
**解释:** 无需交换座位，所有的情侣都已经可以手牵手了。

**提示:**

*   `2n == row.length`
*   `2 <= n <= 30`
*   `n` 是偶数
*   `0 <= row[i] < 2n`
*   `row` 中所有元素均**无重复**

### 算法

#### 思路



#### 代码

```cpp
class Solution {
public:
    int n;
    static const int N = 30;
    int fa[N];
    int size = 0;
    void init(int n) {
        for (int i = 0; i < n; i++)
            fa[i] = i;
        size = n;
    }
    int find(int x) {
        if (x == fa[x])
            return x;
        return fa[x] = find(fa[x]);
    }
    void unionset(int x, int y) {
        x = find(x), y = find(y);
        if (x != y) {
            fa[x] = y;
            size--;
        }
    }
    int minSwapsCouples(vector<int>& row) {
        int m = row.size();
        this->n = m / 2;
        init(n);
        for (int i = 0; i < m; i += 2)
        {
            unionset(row[i] / 2, row[i + 1] / 2);
        }
        return n - size;
    }
};
```

#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[128\. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=problem-list-v2&envId=union-find)
-------------------------------------------------------------------------------------------------------------------------------

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

**输入：**nums = \[100,4,200,1,3,2\]
**输出：**4
**解释：**最长数字连续序列是 \[1, 2, 3, 4\]。它的长度为 4。

**示例 2：**

**输入：**nums = \[0,3,7,2,5,8,4,6,0,1\]
**输出：**9

**提示：**

*   `0 <= nums.length <= 10^5`
*   `-109 <= nums[i] <= 10^9`

### 算法

#### 思路

1. 初始化：使用 `unordered_map` 来维护每个数字的根节点（`fa`）和对应的集合大小（`size`）。每个数字初始时都是一个单独的集合，根节点是其自身，集合大小为 1。
2. 合并相邻数字：遍历数组中的每个数字，如果相邻的数字（如 `num` 和 `num+1`）存在，则将这两个数字所在的集合合并。这通过 `find` 函数找到集合的根节点，并使用 `unite` 函数将两个集合合并。
3. 计算结果：合并完成后，遍历所有集合，找出集合大小的最大值，即为最长连续序列的长度。

这道题之所以不用数组模拟并查集而是用哈希表，是因为数组元素存在负数。

#### 代码

```cpp
class Solution {
public:
    unordered_map<int, int> fa, size;
    void init(vector<int>& nums) {
        for (auto &x : nums) {
            fa[x] = x;
            size[x] = 1;
        }
    }
    int find(int x) {
        if (fa[x] == x) return x;
        return fa[x] = find(fa[x]);
    }
    void unite(int x, int y) {
        x = find(x), y = find(y);
        if (x != y) {
            fa[x] = y;
            size[y] += size[x];
        }
    }
    int longestConsecutive(vector<int>& nums) {
        int n = nums.size();
        init(nums);
        unordered_set<int> nums_set(nums.begin(), nums.end());
        for (auto &num : nums_set) {
            if (nums_set.count(num + 1)) {
                unite(num, num + 1);
            }
        }
        int res = 0;
        for (auto& [k, v] : size) {
            res = max(res, v);
        }
        return res;
    }
};
```

#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[947\. 移除最多的同行或同列石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/description/)
-----------------------------------------------------------------------------------------------------------

`n` 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。

如果一块石头的 **同行或者同列** 上有其他石头存在，那么就可以移除这块石头。

给你一个长度为 `n` 的数组 `stones` ，其中 `stones[i] = [xi, yi]` 表示第 `i` 块石头的位置，返回 **可以移除的石子** 的最大数量。

**示例 1：**

**输入：**stones = \[\[0,0\],\[0,1\],\[1,0\],\[1,2\],\[2,1\],\[2,2\]\]
**输出：**5
**解释：**一种移除 5 块石头的方法如下所示：
1. 移除石头 \[2,2\] ，因为它和 \[2,1\] 同行。
2. 移除石头 \[2,1\] ，因为它和 \[0,1\] 同列。
3. 移除石头 \[1,2\] ，因为它和 \[1,0\] 同行。
4. 移除石头 \[1,0\] ，因为它和 \[0,0\] 同列。
5. 移除石头 \[0,1\] ，因为它和 \[0,0\] 同行。
石头 \[0,0\] 不能移除，因为它没有与另一块石头同行/列。

**示例 2：**

**输入：**stones = \[\[0,0\],\[0,2\],\[1,1\],\[2,0\],\[2,2\]\]
**输出：**3
**解释：**一种移除 3 块石头的方法如下所示：
1. 移除石头 \[2,2\] ，因为它和 \[2,0\] 同行。
2. 移除石头 \[2,0\] ，因为它和 \[0,0\] 同列。
3. 移除石头 \[0,2\] ，因为它和 \[0,0\] 同行。
石头 \[0,0\] 和 \[1,1\] 不能移除，因为它们没有与另一块石头同行/列。

**示例 3：**

**输入：**stones = \[\[0,0\]\]
**输出：**0
**解释：**\[0,0\] 是平面上唯一一块石头，所以不可以移除它。

**提示：**

*   `1 <= stones.length <= 1000`
*   `0 <= xi, yi <= 104`
*   不会有两块石头放在同一个坐标点上

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[839\. 相似字符串组](https://leetcode.cn/problems/similar-string-groups/description/)
-------------------------------------------------------------------------------

如果交换字符串 `X` 中的两个不同位置的字母，使得它和字符串 `Y` 相等，那么称 `X` 和 `Y` 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。

例如，`"tars"` 和 `"rats"` 是相似的 (交换 `0` 与 `2` 的位置)； `"rats"` 和 `"arts"` 也是相似的，但是 `"star"` 不与 `"tars"`，`"rats"`，或 `"arts"` 相似。

总之，它们通过相似性形成了两个关联组：`{"tars", "rats", "arts"}` 和 `{"star"}`。注意，`"tars"` 和 `"arts"` 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。

给你一个字符串列表 `strs`。列表中的每个字符串都是 `strs` 中其它所有字符串的一个字母异位词。请问 `strs` 中有多少个相似字符串组？

**示例 1：**

**输入：**strs = \["tars","rats","arts","star"\]
**输出：**2

**示例 2：**

**输入：**strs = \["omv","ovm"\]
**输出：**1

**提示：**

*   `1 <= strs.length <= 300`
*   `1 <= strs[i].length <= 300`
*   `strs[i]` 只包含小写字母。
*   `strs` 中的所有单词都具有相同的长度，且是彼此的字母异位词。

### 算法

#### 思路

这道题不难想到并查集，关键在于在何时要合并集合。题目说：“如果交换字符串 `X` 中的两个不同位置的字母，使得它和字符串 `Y` 相等，那么称 `X` 和 `Y` 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。”

意思是只要两个字符串只有2个对应位置的字符串不同，或者字符串相同，那就是相似字符串，可以合并。

用字符串在`strs`中的索引作为它们在并查集中的序号，两两枚举字符串，计算两个字符串之间对应位置的不同字符的个数`diff`，只要`diff`不是0或者2，那就说明不是相似字符串，否则就要合并。如果`diff`已经大于2了，也就没有必要再比较下去。

最后返回集合个数`size`。

#### 代码

```cpp
class Solution {
public:
    static const int N = 310;
    int fa[N];
    int size = 0;
    void init(int n) {
        for (int i = 0; i < n; i++)
            fa[i] = i;
        size = n;
    }
    int find(int x) {
        if (x == fa[x])
            return x;
        return fa[x] = find(fa[x]);
    }
    void unionset(int x, int y) {
        x = find(x), y = find(y);
        if (x != y) {
            fa[x] = y;
            size--;
        }
    }
    int numSimilarGroups(vector<string>& strs) {
        int n = strs.size();
        init(n);
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (find(i) != find(j)) {
                    int diff = 0;
                    for (int k = 0; diff < 3 && k < strs[i].size(); k++) {
                        if (strs[i][k] != strs[j][k]) diff++;
                    }
                    if (diff == 0 || diff == 2) // 相同或者有两个位置不同的字母
                        unionset(i, j);
                }
            }
        }
        return size;
    }
};
```

#### 复杂度分析

- 时间复杂度：$O(n^2)$。两两枚举字符串需要耗费$O(n^2)$，每次比较最多3次，每次合并是$O(1)$。$n$是字符串个数。
- 空间复杂度：$O(n)$。

[1970\. 你能穿过矩阵的最后一天](https://leetcode.cn/problems/last-day-where-you-can-still-cross/description/)
--------------------------------------------------------------------------------------------------

给你一个下标从 **1** 开始的二进制矩阵，其中 `0` 表示陆地，`1` 表示水域。同时给你 `row` 和 `col` 分别表示矩阵中行和列的数目。

一开始在第 `0` 天，**整个** 矩阵都是 **陆地** 。但每一天都会有一块新陆地被 **水** 淹没变成水域。给你一个下标从 **1** 开始的二维数组 `cells` ，其中 `cells[i] = [ri, ci]` 表示在第 `i` 天，第 `ri` 行 `ci` 列（下标都是从 **1** 开始）的陆地会变成 **水域** （也就是 `0` 变成 `1` ）。

你想知道从矩阵最 **上面** 一行走到最 **下面** 一行，且只经过陆地格子的 **最后一天** 是哪一天。你可以从最上面一行的 **任意** 格子出发，到达最下面一行的 **任意** 格子。你只能沿着 **四个** 基本方向移动（也就是上下左右）。

请返回只经过陆地格子能从最 **上面** 一行走到最 **下面** 一行的 **最后一天** 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/07/27/1.png)

**输入：**row = 2, col = 2, cells = \[\[1,1\],\[2,1\],\[1,2\],\[2,2\]\]
**输出：**2
**解释：**上图描述了矩阵从第 0 天开始是如何变化的。
可以从最上面一行到最下面一行的最后一天是第 2 天。

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/07/27/2.png)

**输入：**row = 2, col = 2, cells = \[\[1,1\],\[1,2\],\[2,1\],\[2,2\]\]
**输出：**1
**解释：**上图描述了矩阵从第 0 天开始是如何变化的。
可以从最上面一行到最下面一行的最后一天是第 1 天。

**示例 3：**

![](https://assets.leetcode.com/uploads/2021/07/27/3.png)

**输入：**row = 3, col = 3, cells = \[\[1,2\],\[2,1\],\[3,3\],\[2,2\],\[1,1\],\[1,3\],\[2,3\],\[3,2\],\[3,1\]\]
**输出：**3
**解释：**上图描述了矩阵从第 0 天开始是如何变化的。
可以从最上面一行到最下面一行的最后一天是第 3 天。

**提示：**

*   `2 <= row, col <= 2 * 104`
*   `4 <= row * col <= 2 * 104`
*   `cells.length == row * col`
*   `1 <= ri <= row`
*   `1 <= ci <= col`
*   `cells` 中的所有格子坐标都是 **唯一** 的。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[2076\. 处理含限制条件的好友请求](https://leetcode.cn/problems/process-restricted-friend-requests/description/)
---------------------------------------------------------------------------------------------------

给你一个整数 `n` ，表示网络上的用户数目。每个用户按从 `0` 到 `n - 1` 进行编号。

给你一个下标从 **0** 开始的二维整数数组 `restrictions` ，其中 `restrictions[i] = [xi, yi]` 意味着用户 `xi` 和用户 `yi` **不能** 成为 **朋友** ，不管是 **直接** 还是通过其他用户 **间接** 。

最初，用户里没有人是其他用户的朋友。给你一个下标从 **0** 开始的二维整数数组 `requests` 表示好友请求的列表，其中 `requests[j] = [uj, vj]` 是用户 `uj` 和用户 `vj` 之间的一条好友请求。

如果 `uj` 和 `vj` 可以成为 **朋友** ，那么好友请求将会 **成功** 。每个好友请求都会按列表中给出的顺序进行处理（即，`requests[j]` 会在 `requests[j + 1]` 前）。一旦请求成功，那么对所有未来的好友请求而言， `uj` 和 `vj` 将会 **成为直接朋友 。**

返回一个 **布尔数组** `result` ，其中元素遵循此规则：如果第 `j` 个好友请求 **成功** ，那么 `result[j]` 就是 `true` ；否则，为 `false` 。

**注意：**如果 `uj` 和 `vj` 已经是直接朋友，那么他们之间的请求将仍然 **成功** 。

**示例 1：**

**输入：**n = 3, restrictions = \[\[0,1\]\], requests = \[\[0,2\],\[2,1\]\]
**输出：**\[true,false\]
**解释：**
请求 0 ：用户 0 和 用户 2 可以成为朋友，所以他们成为直接朋友。 
请求 1 ：用户 2 和 用户 1 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (1--2--0) 。

**示例 2：**

**输入：**n = 3, restrictions = \[\[0,1\]\], requests = \[\[1,2\],\[0,2\]\]
**输出：**\[true,false\]
**解释：**
请求 0 ：用户 1 和 用户 2 可以成为朋友，所以他们成为直接朋友。 
请求 1 ：用户 0 和 用户 2 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--2--1) 。

**示例 3：**

**输入：**n = 5, restrictions = \[\[0,1\],\[1,2\],\[2,3\]\], requests = \[\[0,4\],\[1,2\],\[3,1\],\[3,4\]\]
**输出：**\[true,false,true,false\]
**解释：**
请求 0 ：用户 0 和 用户 4 可以成为朋友，所以他们成为直接朋友。 
请求 1 ：用户 1 和 用户 2 不能成为朋友，因为他们之间存在限制。
请求 2 ：用户 3 和 用户 1 可以成为朋友，所以他们成为直接朋友。 
请求 3 ：用户 3 和 用户 4 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--4--3--1) 。

**提示：**

*   `2 <= n <= 1000`
*   `0 <= restrictions.length <= 1000`
*   `restrictions[i].length == 2`
*   `0 <= xi, yi <= n - 1`
*   `xi != yi`
*   `1 <= requests.length <= 1000`
*   `requests[j].length == 2`
*   `0 <= uj, vj <= n - 1`
*   `uj != vj`

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[1579\. 保证图可完全遍历](https://leetcode.cn/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/description/)
-----------------------------------------------------------------------------------------------------------------------

Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3  种类型的边：

*   类型 1：只能由 Alice 遍历。
*   类型 2：只能由 Bob 遍历。
*   类型 3：Alice 和 Bob 都可以遍历。

给你一个数组 `edges` ，其中 `edges[i] = [typei, ui, vi]` 表示节点 `ui` 和 `vi` 之间存在类型为 `typei` 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。

返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。

**示例 1：**

**![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex1.png)**

**输入：**n = 4, edges = \[\[3,1,2\],\[3,2,3\],\[1,1,3\],\[1,2,4\],\[1,1,2\],\[2,3,4\]\]
**输出：**2
**解释：**如果删除 \[1,1,2\] 和 \[1,1,3\] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 。

**示例 2：**

**![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex2.png)**

**输入：**n = 4, edges = \[\[3,1,2\],\[3,2,3\],\[1,1,4\],\[2,1,4\]\]
**输出：**0
**解释：**注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。

**示例 3：**

**![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex3.png)**

**输入：**n = 4, edges = \[\[3,2,3\],\[1,1,2\],\[2,3,4\]\]
**输出：**\-1
**解释：**在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。

**提示：**

*   `1 <= n <= 10^5`
*   `1 <= edges.length <= min(10^5, 3 * n * (n-1) / 2)`
*   `edges[i].length == 3`
*   `1 <= edges[i][0] <= 3`
*   `1 <= edges[i][1] < edges[i][2] <= n`
*   所有元组 `(typei, ui, vi)` 互不相同

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[959\. 由斜杠划分区域](https://leetcode.cn/problems/regions-cut-by-slashes/description/)
---------------------------------------------------------------------------------

在由 `1 x 1` 方格组成的 `n x n` 网格 `grid` 中，每个 `1 x 1` 方块由 `'/'`、`'\'` 或空格构成。这些字符会将方块划分为一些共边的区域。

给定网格 `grid` 表示为一个字符串数组，返回 _区域的数量_ 。

请注意，反斜杠字符是转义的，因此 `'\'` 用 `'\\'` 表示。

**示例 1：**

![](https://assets.leetcode.com/uploads/2018/12/15/1.png)

**输入：**grid = \[" /","/ "\]
**输出：**2

**示例 2：**

![](https://assets.leetcode.com/uploads/2018/12/15/2.png)

**输入：**grid = \[" /","  "\]
**输出：**1

**示例 3：**

![](https://assets.leetcode.com/uploads/2018/12/15/4.png)

**输入：**grid = \["/\\\\","\\\\/"\]
**输出：**5
**解释：**回想一下，因为 \\ 字符是转义的，所以 "/\\\\" 表示 /\\，而 "\\\\/" 表示 \\/。

**提示：**

*   `n == grid.length == grid[i].length`
*   `1 <= n <= 30`
*   `grid[i][j]` 是 `'/'`、`'\'`、或 `' '`

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[2812\. 找出最安全路径](https://leetcode.cn/problems/find-the-safest-path-in-a-grid/description/)
------------------------------------------------------------------------------------------

给你一个下标从 **0** 开始、大小为 `n x n` 的二维矩阵 `grid` ，其中 `(r, c)` 表示：

*   如果 `grid[r][c] = 1` ，则表示一个存在小偷的单元格
*   如果 `grid[r][c] = 0` ，则表示一个空单元格

你最开始位于单元格 `(0, 0)` 。在一步移动中，你可以移动到矩阵中的任一相邻单元格，包括存在小偷的单元格。

矩阵中路径的 **安全系数** 定义为：从路径中任一单元格到矩阵中任一小偷所在单元格的 **最小** 曼哈顿距离。

返回所有通向单元格 `(n - 1, n - 1)` 的路径中的 **最大安全系数** 。

单元格 `(r, c)` 的某个 **相邻** 单元格，是指在矩阵中存在的 `(r, c + 1)`、`(r, c - 1)`、`(r + 1, c)` 和 `(r - 1, c)` 之一。

两个单元格 `(a, b)` 和 `(x, y)` 之间的 **曼哈顿距离** 等于 `| a - x | + | b - y |` ，其中 `|val|` 表示 `val` 的绝对值。

**示例 1：**

![](https://assets.leetcode.com/uploads/2023/07/02/example1.png)

**输入：**grid = \[\[1,0,0\],\[0,0,0\],\[0,0,1\]\]
**输出：**0
**解释：**从 (0, 0) 到 (n - 1, n - 1) 的每条路径都经过存在小偷的单元格 (0, 0) 和 (n - 1, n - 1) 。

**示例 2：**

![](https://assets.leetcode.com/uploads/2023/07/02/example2.png)

**输入：**grid = \[\[0,0,1\],\[0,0,0\],\[0,0,0\]\]
**输出：**2
**解释：**
上图所示路径的安全系数为 2：
- 该路径上距离小偷所在单元格（0，2）最近的单元格是（0，0）。它们之间的曼哈顿距离为 | 0 - 0 | + | 0 - 2 | = 2 。
可以证明，不存在安全系数更高的其他路径。

**示例 3：**

![](https://assets.leetcode.com/uploads/2023/07/02/example3.png)

**输入：**grid = \[\[0,0,0,1\],\[0,0,0,0\],\[0,0,0,0\],\[1,0,0,0\]\]
**输出：**2
**解释：**
上图所示路径的安全系数为 2：
- 该路径上距离小偷所在单元格（0，3）最近的单元格是（1，2）。它们之间的曼哈顿距离为 | 0 - 1 | + | 3 - 2 | = 2 。
- 该路径上距离小偷所在单元格（3，0）最近的单元格是（3，2）。它们之间的曼哈顿距离为 | 3 - 3 | + | 0 - 2 | = 2 。
可以证明，不存在安全系数更高的其他路径。

**提示：**

*   `1 <= grid.length == n <= 400`
*   `grid[i].length == n`
*   `grid[i][j]` 为 `0` 或 `1`
*   `grid` 至少存在一个小偷

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[2503\. 矩阵查询可获得的最大分数](https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/description/)
-----------------------------------------------------------------------------------------------------------

给你一个大小为 `m x n` 的整数矩阵 `grid` 和一个大小为 `k` 的数组 `queries` 。

找出一个大小为 `k` 的数组 `answer` ，且满足对于每个整数 `queries[i]` ，你从矩阵 **左上角** 单元格开始，重复以下过程：

*   如果 `queries[i]` **严格** 大于你当前所处位置单元格，如果该单元格是第一次访问，则获得 1 分，并且你可以移动到所有 `4` 个方向（上、下、左、右）上任一 **相邻** 单元格。
*   否则，你不能获得任何分，并且结束这一过程。

在过程结束后，`answer[i]` 是你可以获得的最大分数。注意，对于每个查询，你可以访问同一个单元格 **多次** 。

返回结果数组 `answer` 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2022/10/19/yetgriddrawio.png)

**输入：**grid = \[\[1,2,3\],\[2,5,7\],\[3,5,1\]\], queries = \[5,6,2\]
**输出：**\[5,8,1\]
**解释：**上图展示了每个查询中访问并获得分数的单元格。

**示例 2：**

![](https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png)

**输入：**grid = \[\[5,2,1\],\[1,1,2\]\], queries = \[3\]
**输出：**\[0\]
**解释：**无法获得分数，因为左上角单元格的值大于等于 3 。

**提示：**

*   `m == grid.length`
*   `n == grid[i].length`
*   `2 <= m, n <= 1000`
*   `4 <= m * n <= 105`
*   `k == queries.length`
*   `1 <= k <= 104`
*   `1 <= grid[i][j], queries[i] <= 106`

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[2867\. 统计树中的合法路径数目](https://leetcode.cn/problems/count-valid-paths-in-a-tree/description/)
-------------------------------------------------------------------------------------------

给你一棵 `n` 个节点的无向树，节点编号为 `1` 到 `n` 。给你一个整数 `n` 和一个长度为 `n - 1` 的二维整数数组 `edges` ，其中 `edges[i] = [ui, vi]` 表示节点 `ui` 和 `vi` 在树中有一条边。

请你返回树中的 **合法路径数目** 。

如果在节点 `a` 到节点 `b` 之间 **恰好有一个** 节点的编号是质数，那么我们称路径 `(a, b)` 是 **合法的** 。

**注意：**

*   路径 `(a, b)` 指的是一条从节点 `a` 开始到节点 `b` 结束的一个节点序列，序列中的节点 **互不相同** ，且相邻节点之间在树上有一条边。
*   路径 `(a, b)` 和路径 `(b, a)` 视为 **同一条** 路径，且只计入答案 **一次** 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2023/08/27/example1.png)

**输入：**n = 5, edges = \[\[1,2\],\[1,3\],\[2,4\],\[2,5\]\]
**输出：**4
**解释：**恰好有一个质数编号的节点路径有：
- (1, 2) 因为路径 1 到 2 只包含一个质数 2 。
- (1, 3) 因为路径 1 到 3 只包含一个质数 3 。
- (1, 4) 因为路径 1 到 4 只包含一个质数 2 。
- (2, 4) 因为路径 2 到 4 只包含一个质数 2 。
只有 4 条合法路径。

**示例 2：**

![](https://assets.leetcode.com/uploads/2023/08/27/example2.png)

**输入：**n = 6, edges = \[\[1,2\],\[1,3\],\[2,4\],\[3,5\],\[3,6\]\]
**输出：**6
**解释：**恰好有一个质数编号的节点路径有：
- (1, 2) 因为路径 1 到 2 只包含一个质数 2 。
- (1, 3) 因为路径 1 到 3 只包含一个质数 3 。
- (1, 4) 因为路径 1 到 4 只包含一个质数 2 。
- (1, 6) 因为路径 1 到 6 只包含一个质数 3 。
- (2, 4) 因为路径 2 到 4 只包含一个质数 2 。
- (3, 6) 因为路径 3 到 6 只包含一个质数 3 。
只有 6 条合法路径。

**提示：**

*   `1 <= n <= 105`
*   `edges.length == n - 1`
*   `edges[i].length == 2`
*   `1 <= ui, vi <= n`
*   输入保证 `edges` 形成一棵合法的树。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[2421\. 好路径的数目](https://leetcode.cn/problems/number-of-good-paths/description/)
-------------------------------------------------------------------------------

给你一棵 `n` 个节点的树（连通无向无环的图），节点编号从 `0` 到 `n - 1` 且恰好有 `n - 1` 条边。

给你一个长度为 `n` 下标从 **0** 开始的整数数组 `vals` ，分别表示每个节点的值。同时给你一个二维整数数组 `edges` ，其中 `edges[i] = [ai, bi]` 表示节点 `ai` 和 `bi` 之间有一条 **无向** 边。

一条 **好路径** 需要满足以下条件：

1.  开始节点和结束节点的值 **相同** 。
2.  开始节点和结束节点中间的所有节点值都 **小于等于** 开始节点的值（也就是说开始节点的值应该是路径上所有节点的最大值）。

请你返回不同好路径的数目。

注意，一条路径和它反向的路径算作 **同一** 路径。比方说， `0 -> 1` 与 `1 -> 0` 视为同一条路径。单个节点也视为一条合法路径。

**示例 1：**

![](https://assets.leetcode.com/uploads/2022/08/04/f9caaac15b383af9115c5586779dec5.png)

**输入：**vals = \[1,3,2,1,3\], edges = \[\[0,1\],\[0,2\],\[2,3\],\[2,4\]\]
**输出：**6
**解释：**总共有 5 条单个节点的好路径。
还有 1 条好路径：1 -> 0 -> 2 -> 4 。
（反方向的路径 4 -> 2 -> 0 -> 1 视为跟 1 -> 0 -> 2 -> 4 一样的路径）
注意 0 -> 2 -> 3 不是一条好路径，因为 vals\[2\] > vals\[0\] 。

**示例 2：**

![](https://assets.leetcode.com/uploads/2022/08/04/149d3065ec165a71a1b9aec890776ff.png)

**输入：**vals = \[1,1,2,2,3\], edges = \[\[0,1\],\[1,2\],\[2,3\],\[2,4\]\]
**输出：**7
**解释：**总共有 5 条单个节点的好路径。
还有 2 条好路径：0 -> 1 和 2 -> 3 。

**示例 3：**

![](https://assets.leetcode.com/uploads/2022/08/04/31705e22af3d9c0a557459bc7d1b62d.png)

**输入：**vals = \[1\], edges = \[\]
**输出：**1
**解释：**这棵树只有一个节点，所以只有一条好路径。

**提示：**

*   `n == vals.length`
*   `1 <= n <= 3 * 104`
*   `0 <= vals[i] <= 105`
*   `edges.length == n - 1`
*   `edges[i].length == 2`
*   `0 <= ai, bi < n`
*   `ai != bi`
*   `edges` 表示一棵合法的树。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[2157\. 字符串分组](https://leetcode.cn/problems/groups-of-strings/description/)
---------------------------------------------------------------------------

给你一个下标从 **0** 开始的字符串数组 `words` 。每个字符串都只包含 **小写英文字母** 。`words` 中任意一个子串中，每个字母都至多只出现一次。

如果通过以下操作之一，我们可以从 `s1` 的字母集合得到 `s2` 的字母集合，那么我们称这两个字符串为 **关联的** ：

*   往 `s1` 的字母集合中添加一个字母。
*   从 `s1` 的字母集合中删去一个字母。
*   将 `s1` 中的一个字母替换成另外任意一个字母（也可以替换为这个字母本身）。

数组 `words` 可以分为一个或者多个无交集的 **组** 。如果一个字符串与另一个字符串关联，那么它们应当属于同一个组。

注意，你需要确保分好组后，一个组内的任一字符串与其他组的字符串都不关联。可以证明在这个条件下，分组方案是唯一的。

请你返回一个长度为 `2` 的数组 `ans` ：

*   `ans[0]` 是 `words` 分组后的 **总组数** 。
*   `ans[1]` 是字符串数目最多的组所包含的字符串数目。

**示例 1：**

**输入：**words = \["a","b","ab","cde"\]
**输出：**\[2,3\]
**解释：**
- words\[0\] 可以得到 words\[1\] （将 'a' 替换为 'b'）和 words\[2\] （添加 'b'）。所以 words\[0\] 与 words\[1\] 和 words\[2\] 关联。
- words\[1\] 可以得到 words\[0\] （将 'b' 替换为 'a'）和 words\[2\] （添加 'a'）。所以 words\[1\] 与 words\[0\] 和 words\[2\] 关联。
- words\[2\] 可以得到 words\[0\] （删去 'b'）和 words\[1\] （删去 'a'）。所以 words\[2\] 与 words\[0\] 和 words\[1\] 关联。
- words\[3\] 与 words 中其他字符串都不关联。
所以，words 可以分成 2 个组 \["a","b","ab"\] 和 \["cde"\] 。最大的组大小为 3 。

**示例 2：**

**输入：**words = \["a","ab","abc"\]
**输出：**\[1,3\]
**解释：**
- words\[0\] 与 words\[1\] 关联。
- words\[1\] 与 words\[0\] 和 words\[2\] 关联。
- words\[2\] 与 words\[1\] 关联。
由于所有字符串与其他字符串都关联，所以它们全部在同一个组内。
所以最大的组大小为 3 。

**提示：**

*   `1 <= words.length <= 2 * 104`
*   `1 <= words[i].length <= 26`
*   `words[i]` 只包含小写英文字母。
*   `words[i]` 中每个字母最多只出现一次。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[1632\. 矩阵转换后的秩](https://leetcode.cn/problems/rank-transform-of-a-matrix/description/)
--------------------------------------------------------------------------------------

给你一个 `m x n` 的矩阵 `matrix` ，请你返回一个新的矩阵 `answer` ，其中 `answer[row][col]` 是 `matrix[row][col]` 的秩。

每个元素的 **秩** 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：

*   秩是从 1 开始的一个整数。
*   如果两个元素 `p` 和 `q` 在 **同一行** 或者 **同一列** ，那么：
    *   如果 `p < q` ，那么 `rank(p) < rank(q)`
    *   如果 `p == q` ，那么 `rank(p) == rank(q)`
    *   如果 `p > q` ，那么 `rank(p) > rank(q)`
*   **秩** 需要越 **小** 越好。

题目保证按照上面规则 `answer` 数组是唯一的。

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank1.jpg)

**输入：**matrix = \[\[1,2\],\[3,4\]\]
**输出：**\[\[1,2\],\[2,3\]\]
**解释：**
matrix\[0\]\[0\] 的秩为 1 ，因为它是所在行和列的最小整数。
matrix\[0\]\[1\] 的秩为 2 ，因为 matrix\[0\]\[1\] > matrix\[0\]\[0\] 且 matrix\[0\]\[0\] 的秩为 1 。
matrix\[1\]\[0\] 的秩为 2 ，因为 matrix\[1\]\[0\] > matrix\[0\]\[0\] 且 matrix\[0\]\[0\] 的秩为 1 。
matrix\[1\]\[1\] 的秩为 3 ，因为 matrix\[1\]\[1\] > matrix\[0\]\[1\]， matrix\[1\]\[1\] > matrix\[1\]\[0\] 且 matrix\[0\]\[1\] 和 matrix\[1\]\[0\] 的秩都为 2 。

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank2.jpg)

**输入：**matrix = \[\[7,7\],\[7,7\]\]
**输出：**\[\[1,1\],\[1,1\]\]

**示例 3：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank3.jpg)

**输入：**matrix = \[\[20,-21,14\],\[-19,4,19\],\[22,-47,24\],\[-19,4,19\]\]
**输出：**\[\[4,2,3\],\[1,3,4\],\[5,1,6\],\[1,3,4\]\]

**提示：**

*   `m == matrix.length`
*   `n == matrix[i].length`
*   `1 <= m, n <= 500`
*   `-109 <= matrix[row][col] <= 109`

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。



[803\. 打砖块](https://leetcode.cn/problems/bricks-falling-when-hit/description/)
------------------------------------------------------------------------------

有一个 `m x n` 的二元网格 `grid` ，其中 `1` 表示砖块，`0` 表示空白。砖块 **稳定**（不会掉落）的前提是：

*   一块砖直接连接到网格的顶部，或者
*   至少有一块相邻（4 个方向之一）砖块 **稳定** 不会掉落时

给你一个数组 `hits` ，这是需要依次消除砖块的位置。每当消除 `hits[i] = (rowi, coli)` 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而 **掉落** 。一旦砖块掉落，它会 **立即** 从网格 `grid` 中消失（即，它不会落在其他稳定的砖块上）。

返回一个数组 `result` ，其中 `result[i]` 表示第 `i` 次消除操作对应掉落的砖块数目。

**注意**，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。

**示例 1：**

**输入：**grid = \[\[1,0,0,0\],\[1,1,1,0\]\], hits = \[\[1,0\]\]
**输出：**\[2\]
**解释：**网格开始为：
\[\[1,0,0,0\]，
 \[**1**,1,1,0\]\]
消除 (1,0) 处加粗的砖块，得到网格：
\[\[1,0,0,0\]
 \[0,**1**,**1**,0\]\]
两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：
\[\[1,0,0,0\],
 \[0,0,0,0\]\]
因此，结果为 \[2\] 。

**示例 2：**

**输入：**grid = \[\[1,0,0,0\],\[1,1,0,0\]\], hits = \[\[1,1\],\[1,0\]\]
**输出：**\[0,0\]
**解释：**网格开始为：
\[\[1,0,0,0\],
 \[1,**1**,0,0\]\]
消除 (1,1) 处加粗的砖块，得到网格：
\[\[1,0,0,0\],
 \[1,0,0,0\]\]
剩下的砖都很稳定，所以不会掉落。网格保持不变：
\[\[1,0,0,0\], 
 \[**1**,0,0,0\]\]
接下来消除 (1,0) 处加粗的砖块，得到网格：
\[\[1,0,0,0\],
 \[0,0,0,0\]\]
剩下的砖块仍然是稳定的，所以不会有砖块掉落。
因此，结果为 \[0,0\] 。

**提示：**

*   `m == grid.length`
*   `n == grid[i].length`
*   `1 <= m, n <= 200`
*   `grid[i][j]` 为 `0` 或 `1`
*   `1 <= hits.length <= 4 * 104`
*   `hits[i].length == 2`
*   `0 <= xi <= m - 1`
*   `0 <= yi <= n - 1`
*   所有 `(xi, yi)` 互不相同

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[1569\. 将子数组重新排序得到同一个二叉搜索树的方案数](https://leetcode.cn/problems/number-of-ways-to-reorder-array-to-get-same-bst/description/)
--------------------------------------------------------------------------------------------------------------------------

给你一个数组 `nums` 表示 `1` 到 `n` 的一个排列。我们按照元素在 `nums` 中的顺序依次插入一个初始为空的二叉搜索树（BST）。请你统计将 `nums` 重新排序后，统计满足如下条件的方案数：重排后得到的二叉搜索树与 `nums` 原本数字顺序得到的二叉搜索树相同。

比方说，给你 `nums = [2,1,3]`，我们得到一棵 2 为根，1 为左孩子，3 为右孩子的树。数组 `[2,3,1]` 也能得到相同的 BST，但 `[3,2,1]` 会得到一棵不同的 BST 。

请你返回重排 `nums` 后，与原数组 `nums` 得到相同二叉搜索树的方案数。

由于答案可能会很大，请将结果对 `10^9 + 7` 取余数。

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/bb.png)

**输入：**nums = \[2,1,3\]
**输出：**1
**解释：**我们将 nums 重排， \[2,3,1\] 能得到相同的 BST 。没有其他得到相同 BST 的方案了。

**示例 2：**

**![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex1.png)**

**输入：**nums = \[3,4,5,1,2\]
**输出：**5
**解释：**下面 5 个数组会得到相同的 BST：
\[3,1,2,4,5\]
\[3,1,4,2,5\]
\[3,1,4,5,2\]
\[3,4,1,2,5\]
\[3,4,1,5,2\]

**示例 3：**

**![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex4.png)**

**输入：**nums = \[1,2,3\]
**输出：**0
**解释：**没有别的排列顺序能得到相同的 BST 。

**提示：**

*   `1 <= nums.length <= 1000`
*   `1 <= nums[i] <= nums.length`
*   `nums` 中所有数 **互不相同** 。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

[3235\. 判断矩形的两个角落是否可达](https://leetcode.cn/problems/check-if-the-rectangle-corner-is-reachable/description/)
------------------------------------------------------------------------------------------------------------

给你两个正整数 `xCorner` 和 `yCorner` 和一个二维整数数组 `circles` ，其中 `circles[i] = [xi, yi, ri]` 表示一个圆心在 `(xi, yi)` 半径为 `ri` 的圆。

坐标平面内有一个左下角在原点，右上角在 `(xCorner, yCorner)` 的矩形。你需要判断是否存在一条从左下角到右上角的路径满足：路径 **完全** 在矩形内部，**不会** 触碰或者经过 **任何** 圆的内部和边界，同时 **只** 在起点和终点接触到矩形。

如果存在这样的路径，请你返回 `true` ，否则返回 `false` 。

**示例 1：**

**输入：**X = 3, Y = 4, circles = \[\[2,1,1\]\]

**输出：**true

**解释：**

![](https://assets.leetcode.com/uploads/2024/05/18/example2circle1.png)

黑色曲线表示一条从 `(0, 0)` 到 `(3, 4)` 的路径。

**示例 2：**

**输入：**X = 3, Y = 3, circles = \[\[1,1,2\]\]

**输出：**false

**解释：**

![](https://assets.leetcode.com/uploads/2024/05/18/example1circle.png)

不存在从 `(0, 0)` 到 `(3, 3)` 的路径。

**示例 3：**

**输入：**X = 3, Y = 3, circles = \[\[2,1,1\],\[1,2,1\]\]

**输出：**false

**解释：**

![](https://assets.leetcode.com/uploads/2024/05/18/example0circle.png)

不存在从 `(0, 0)` 到 `(3, 3)` 的路径。

**示例 4：**

**输入：**X = 4, Y = 4, circles = \[\[5,5,1\]\]

**输出：**true

**解释：**

![](https://assets.leetcode.com/uploads/2024/08/04/rectangles.png)

**提示：**

*   `3 <= xCorner, yCorner <= 109`
*   `1 <= circles.length <= 1000`
*   `circles[i].length == 3`
*   `1 <= xi, yi, ri <= 109`

### 算法

#### 思路



#### 代码

```cpp

```

#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

## [LCP 71. 集水器](https://leetcode.cn/problems/kskhHQ/description/)

字符串数组 `shape` 描述了一个二维平面中的矩阵形式的集水器，`shape[i][j]` 表示集水器的第 `i` 行 `j` 列为：

- `'l'`表示向左倾斜的隔板（即从左上到右下）；
- `'r'`表示向右倾斜的隔板（即从左下到右上）；
- `'.'` 表示此位置没有隔板![image.png](https://pic.leetcode-cn.com/1664424667-wMnPja-image.png)

已知当隔板构成存储容器可以存水，每个方格代表的蓄水量为 `2`。集水器初始浸泡在水中，除内部密闭空间外，所有位置均被水填满。 现将其从水中竖直向上取出，请返回集水器最终的蓄水量。

**注意：**

- 隔板具有良好的透气性，因此空气可以穿过隔板，但水无法穿过

**示例 1：**

> 输入： `shape = ["....rl","l.lr.r",".l..r.","..lr.."]`
>
> 输出：`18`
>
> 解释：如下图所示，由于空气会穿过隔板，因此红框区域没有水![image.png](https://pic.leetcode-cn.com/1664436239-eyYxeP-image.png)

**示例 2：**

> 输入： `shape = [".rlrlrlrl","ll..rl..r",".llrrllrr","..lr..lr."]` 输出：`18`
>
> 解释：如图所示。由于红框右侧未闭合，因此多余的水会从该处流走。![image.png](https://pic.leetcode-cn.com/1664436082-SibVMv-image.png)

**示例 3：**

> 输入： `shape = ["rlrr","llrl","llr."]` 输出：`6`
>
> 解释：如图所示。![image.png](https://pic.leetcode-cn.com/1664424855-dwpUHO-image.png)

**示例 4：**

> 输入： `shape = ["...rl...","..r..l..",".r.rl.l.","r.r..l.l","l.l..rl.",".l.lr.r.","..l..r..","...lr..."]`
>
> 输出：`30`
>
> 解释：如下图所示。由于中间为内部密闭空间，无法蓄水。![image.png](https://pic.leetcode-cn.com/1664424894-mClEXh-image.png)

**提示**：

- `1 <= shape.length <= 50`
- `1 <= shape[i].length <= 50`
- `shape[i][j]` 仅为 `'l'`、`'r'` 或 `'.'`

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。



### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。

### 算法

#### 思路



#### 代码

```cpp

```



#### 复杂度分析

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(n)$。